#-------------------------------------------------------------------------------
picea <- picea %>%
mutate(DBH = as.numeric(DBH.23),
MCW = mapply(MCW, SPP = SPP, DBH = DBH))
#-------------------------------------------------------------------------------
# CCF
#-------------------------------------------------------------------------------
spruce.ccf <- picea%>%
mutate(CW = mapply(MCW,SPP=SPP,DBH=DBH),
CA = (CW/2)^2*pi,
CA.exp = CA*10)%>%
group_by(BLOCK,PLOT)%>%
summarize(CCF = (sum(CA.exp)/43560)*100)
picea <- picea %>%
left_join(spruce.ccf %>% select(BLOCK, PLOT, CCF),
by = c("BLOCK", "PLOT"))
--------------------------------------------------------------------
# Site Index - (calculated at tree level, summarize by Block and Plot)
#-------------------------------------------------------------------------------
sum(is.na(picea$final.ht))  # Number of missing values in final.ht
picea <- picea %>%
filter(!is.na(final.ht))
#vicary.site
picea <- picea%>%
mutate(vicary.si=mapply(vicary.site,SPP="RS",ht=final.ht, age=28))
picea %>%
group_by(BLOCK, PLOT) %>%
summarise(mean.vicary.si = mean(vicary.si, na.rm = TRUE))
#steinman.site
picea <- picea%>%
mutate(steinman.si=mapply(steinman.site, SPP="RS", HT=final.ht, AGE=28))
picea %>%
group_by(BLOCK, PLOT) %>%
summarise(mean.steinman.si = mean(steinman.si, na.rm = TRUE))
#-------------------------------------------------------------------------------
# Top Height/HT40 (vicary height) - (tree or plot level?)
#-------------------------------------------------------------------------------
picea <- picea%>%
mutate(topht=mapply(vicary.height,SPP="RS", age=28, si=vicary.si))
picea %>%
group_by(BLOCK, PLOT) %>%
summarise(spruce.topht = mean(topht, na.rm = TRUE))
#-------------------------------------------------------------------------------
# qmd - (plot level)
#-------------------------------------------------------------------------------
spruce.qmd <- picea %>%
group_by(BLOCK, PLOT) %>%
summarise(qmd = sqrt(sum(DBH.23^2, na.rm = TRUE) / n()), .groups = "drop")
mean(spruce.qmd$qmd)
picea <- picea %>%
left_join(spruce.qmd %>% select(BLOCK, PLOT, qmd),
by = c("BLOCK", "PLOT"))
#-------------------------------------------------------------------------------
# Relative density index - (plot level)
#-------------------------------------------------------------------------------
spruce.rd <- picea %>%
mutate(rdi = mapply(relative.density.index, bapa, qmd))
spruce.rd_summary <- spruce.rd %>%
group_by(BLOCK, PLOT) %>%
summarise(rdi = mean(rdi, na.rm = TRUE))  # Ensure only one value per BLOCK-PLOT
picea <- picea %>%
left_join(spruce.rd_summary, by = c("BLOCK", "PLOT"))
#-------------------------------------------------------------------------------
# Relative spacing - (plot level)
#-------------------------------------------------------------------------------
str(relative.spacing)
picea <- picea %>%
mutate(rs=mapply(relative.spacing,tpa=tpa, domht=topht))
picea %>%
group_by(BLOCK, PLOT) %>%
summarise_at(vars(rs), list(name = mean))
#-------------------------------------------------------------------------------
# Stand density index - (plot level)
#-------------------------------------------------------------------------------
picea <- picea %>%
mutate(sdi=mapply(stand.density.index,tpa=tpa, qmd=qmd))
picea %>%
group_by(BLOCK, PLOT) %>%
summarise_at(vars(sdi), list(name = mean))
xyplot(qmd~tpa|CODE,data=picea)
#-------------------------------------------------------------------------------
# Kozak volume calculation at the individual tree level (ft3)
#-------------------------------------------------------------------------------
require(devtools)
#devtools::install("C:/Users/ashley.lynn.carter/Documents/GitHub/GreenTimbMerch")
require(GreenTimbMerch)
picea$dbh.cm <- picea$DBH.23*2.54
picea$ht.m <- picea$ht.fit/3.28
spruce <- dplyr::filter(picea,SPP=="NS"|SPP=="WS"|SPP=="RS"|SPP=="BS")
spruce$new.vol.m3 <- mapply(KozakTreeVol,'ib',spruce$SPP,spruce$dbh.cm,spruce$ht.m,
Planted=TRUE)
#convert to m3/ha
spruce <- spruce %>%
group_by(BLOCK,PLOT) %>%
mutate(
p.vol.ha = sum(new.vol.m3, na.rm = TRUE) * 10 * 2.47105
)
#convert to ft3/ac
spruce <- spruce %>%
group_by(BLOCK, PLOT) %>%
mutate(
p.vol.ac = p.vol.ha * 14.28
)
#-------------------------------------------------------------------------------
# Variable selection procedures using VSURF package for integer response variable
#-------------------------------------------------------------------------------
require(randomForest)
require(VSURF)
require(caTools)
require(pscl)
spruce$deductclass <- 5*as.integer((spruce$T_DEDUCT+(5/2))/5)
hist(spruce$deductclass)
d.set <- spruce
d.set$T_DEDUCT[is.na(d.set$T_DEDUCT)] <- 999
d.set <- dplyr::filter(d.set,T_DEDUCT<998)
#d.set$HT.23[is.na(d.set$HT.23)] <- 0
#d.set <- dplyr::filter(d.set,HT.23>0)
plot(d.set$DBH.23,d.set$HT.23)
names(d.set)
mod3.1 <- zeroinfl(deductclass~rs+sdi+bal+roughness+CODE|sdi+bal+CODE+SPP,
data=d.set,dist="negbin")
summary(mod3.1)
performance(mod3.1)
predictions <- predict(mod3.1, type = "response")
observed <- d.set$deductclass
mb <- mean(observed - predictions)
mab <- mean(abs(observed - predictions))
mb
mab
spruce$fit.deduction <- ifelse(spruce$SPP=="RS"|
spruce$SPP=="WS"|
spruce$SPP=="BS"|
spruce$SPP=="NS",predict(mod3.1,type="response"),0)
spruce$fit.deduct.class <- (5*as.integer((spruce$fit.deduction+(5/2))/5))/100
# will use the modeled reduction
spruce$fit.deduct.class[spruce$fit.deduct.class>1] <- 1
spruce$adj.vol <- spruce$p.vol.ac*spruce$fit.deduct.class
plot(spruce$p.vol.ac,spruce$adj.vol,ylim=c(0,2000),xlim=c(0,2000))
spruce$final.vol <- spruce$p.vol.ac-spruce$adj.vol
#convert final.vol to m3/ha
spruce <- spruce %>%
mutate(final.vol.ha = final.vol * 0.0698)
#needed to average it since orginally calculate at tree-level
final.vol.ha <- spruce %>%
group_by(BLOCK, PLOT) %>%
summarise(final.vol.ha.avg = mean(final.vol.ha, na.rm = TRUE),
.groups = 'drop')
spruce <- spruce %>%
left_join(final.vol.ha, by = c("BLOCK", "PLOT"))
hcb.mod1 <- lm(HCB.23 ~final.ht + DBH.23  + vpdmax + factor(SPP), data = picea)
summary(hcb.mod1)
performance(hcb.mod1)
AIC(hcb.mod4)
hcb.mod4 <- lm(HCB.23 ~final.ht + DBH.23 +factor(SPP) + factor(CODE),data = picea) #log final.ht or DBH.23 did not improve AIC
summary(hcb.mod4)
performance(hcb.mod4)
AIC(hcb.mod1, hcb.mod4) #hcb.mod4 is better model, hcb.mod1 had a higher R2 but also high AIC
rmse <- rmse(hcb.mod4)
print(paste("RMSE:", rmse))
MB <- mean(residuals)
print(paste("Mean Bias (MB):", MB))
MAB <- mean(abs(residuals))
print(paste("Mean Absolute Bias (MAB):", MAB))
# predict hcb.mod4 on all spruce, and join to picea df
picea$hcb.fit <- ifelse(picea$SPP=="RS"|
picea$SPP=="WS"|
picea$SPP=="BS"|
picea$SPP=="NS",predict(hcb.mod4,type="response"),0)
picea$final.hcb <- ifelse(!is.na(picea$HCB.23), picea$HCB.23, picea$hcb.fit)
#-------------------------------------------------------------------------------
# Crown Stratification
#-------------------------------------------------------------------------------
picea$fit.hcb <- predict(hcb.mod4,picea)
spruce.only <- dplyr::filter(picea,SPP=="RS"|SPP=="NS"|SPP=="WS"|SPP=="BS")
spruce.only$HT.23 <- ifelse(is.na(spruce.only$HT.23),spruce.only$final.ht,spruce.only$HT.23)
spruce.only$fit.hcb <- predict(hcb.mod4,spruce.only)
spruce.only$fit.hcb <- ifelse(spruce.only$fit.hcb<0.3,0.3,spruce.only$fit.hcb)
cpi.frame <- spruce.only%>%
group_by(BLOCK,PLOT)%>%
summarize(Top = max(HT.23),
Low = min(fit.hcb))
cpi.frame <- as.data.frame(cpi.frame)
cpi.frame$uid.b <- paste0(cpi.frame$BLOCK,".",cpi.frame$PLOT)
nd <- data.frame(uid.b = rep(c(cpi.frame$uid.b),each=100),
prop = seq(from=0,to=1,length=100))
nd2 <- left_join(nd,cpi.frame)
head(nd2)
names(spruce.only)
al <- spruce.only[c(1:8,12,66:80,87)]
head(al)
pa <- left_join(nd2,al)
head(pa)
#-------------------------------------------------------------------------------
# Crown Stratification
#-------------------------------------------------------------------------------
picea$fit.hcb <- predict(hcb.mod4,picea)
spruce.only <- dplyr::filter(picea,SPP=="RS"|SPP=="NS"|SPP=="WS"|SPP=="BS")
spruce.only$HT.23 <- ifelse(is.na(spruce.only$HT.23),spruce.only$final.ht,spruce.only$HT.23)
spruce.only$fit.hcb <- predict(hcb.mod4,spruce.only)
spruce.only$fit.hcb <- ifelse(spruce.only$fit.hcb<0.3,0.3,spruce.only$fit.hcb)
cpi.frame <- spruce.only%>%
group_by(BLOCK,PLOT)%>%
summarize(Top = max(HT.23),
Low = min(fit.hcb))
cpi.frame <- as.data.frame(cpi.frame)
cpi.frame$uid.b <- paste0(cpi.frame$BLOCK,".",cpi.frame$PLOT)
nd <- data.frame(uid.b = rep(c(cpi.frame$uid.b),each=100),
prop = seq(from=0,to=1,length=100))
nd2 <- left_join(nd,cpi.frame)
head(nd2)
names(spruce.only)
al <- spruce.only[c(1:8,12,66:80,87)]
head(al)
pa <- left_join(nd2,al)
head(pa)
pa$top.prop <- (pa$final.ht-pa$Low)/(pa$Top-pa$Low)
pa$bot.prop <- (pa$fit.hcb-pa$Low)/(pa$Top-pa$Low)
pa$crown.point <- ifelse(pa$prop>=pa$bot.prop&pa$prop<=pa$top.prop,1,0)
head(pa)
xyplot(crown.point~DBH.23|SPP,data=pa)
#pa$prop <- as.integer(pa$prop)
cr.demog <- pa%>%
mutate(ef = 10)%>%
group_by(BLOCK,PLOT,SPP,CODE,prop)%>%
summarize(cr.points = sum((crown.point)*10))
COLORS = c("blue", "gold", "red", "green")
xyplot(cr.points~prop|CODE,data=cr.demog,type=c("p","l"),
group=SPP,auto.key=TRUE)
# obviously the spruce only filter doesn't work.. oh well.
ca <- dplyr::filter(cr.demog,cr.points>0&CODE=="RW"|CODE=="NR"|CODE=="NW"|CODE=="BR"|CODE=="BW"|CODE=="BN")
ca <- dplyr::filter(cr.demog, cr.points > 0 &
(CODE %in% c("RW", "NR", "NW", "BR", "BW", "BN")) &
(SPP %in% c("BS", "NS", "RS", "WS")) &
!((SPP %in% c("BS", "WS") & CODE == "NR") |
(SPP %in% c("RS", "WS") & CODE == "BN") |
(SPP %in% c("BS", "NS") & CODE == "RW") |
(SPP %in% c("RS", "NS") & CODE == "BW")))
ca$SPP <- factor(ca$SPP, levels = c("BS", "NS", "RS", "WS"))
xyplot(prop~cr.points|CODE,data=ca,type=c("l"))
ca.avg <- ca %>%
group_by(CODE, SPP, prop) %>%
summarise(cr.points = mean(cr.points, na.rm = TRUE), .groups = "drop")
xyplot(cr.points ~ prop | CODE, data = ca.avg, type = c("l"),
group = SPP, auto.key = list(points = FALSE, lines = TRUE, columns = 2))
xyplot(cr.points ~ prop | CODE,
data = ca.avg,
type = c("l"),
group = SPP,
auto.key = list(points = FALSE, lines = TRUE, columns = 1, title = "Species", space = "right"),
xlab = "Proportion",
ylab = "Crown Points")
ca.avg.smooth <- ca.avg %>%
group_by(CODE, SPP) %>%
do({
smoothed <- smooth.spline(.$prop, .$cr.points, spar = 0.7)
data.frame(prop = smoothed$x, cr.points = pmax(smoothed$y, 0))  # Ensures no negative values
}) %>%
ungroup()
xyplot(prop~cr.points | CODE,
data = ca.avg.smooth,
type = "l",
group = SPP,
auto.key = list(points = FALSE, lines = TRUE, columns = 1, title = "Species", space = "right"),
xlab = "Crown Points",
ylab = "Proportion")
#fit beta distribution for cr.points use ca dataframe (includes each CODE rep df=2)
library(fitdistrplus)
library(agricolae)
beta <- function(ca) {
ca <- ca[ca$cr.points > 0, ]
fit <- fitdist(ca$prop, "beta", method = "mme")
return(data.frame(alpha = fit$estimate["shape1"], beta = fit$estimate["shape2"]))
}
beta.fit <- ca %>%
group_by(BLOCK, CODE, SPP) %>%
group_modify(~ beta(.x)) %>%
ungroup()
print(beta.fit)
CODE <- beta.fit %>%
filter(CODE == "RW", SPP %in% c("RS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
alpha.tukey <- HSD.test(alpha.aov, "SPP", group = TRUE)
beta.tukey <- HSD.test(beta.aov, "SPP", group = TRUE)
alpha.tukey
beta.tukey
library(multcomp)
beta.fit$SPP <- as.factor(beta.fit$SPP)
beta.fit$CODE <- as.factor(beta.fit$CODE)
amod <- lm(alpha ~ SPP + CODE, data = beta.fit)
bmod <- lm(beta ~ SPP + CODE, data = beta.fit)
summary(amod)
summary(bmod)
alpha.glht <- glht(amod, linfct = mcp(CODE = "Tukey"))
summary(alpha.glht, p.adjust.method = "bonferroni")
beta.glht <- glht(bmod, linfct = mcp(CODE = "Tukey"))
summary(beta.glht, p.adjust.method = "bonferroni")
beta <- function(ca) {
ca <- ca[ca$cr.points > 0, ]
fit <- fitdist(ca$prop, "beta", method = "mme")
return(data.frame(alpha = fit$estimate["shape1"], beta = fit$estimate["shape2"]))
}
beta.fit <- ca %>%
group_by(CODE, SPP) %>%
group_modify(~ beta(.x)) %>%
ungroup()
print(beta.fit)
CODE <- beta.fit %>%
filter(CODE == "RW", SPP %in% c("RS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
beta.fit <- ca %>%
group_by(BLOCK, CODE, SPP) %>%
group_modify(~ beta(.x)) %>%
ungroup()
print(beta.fit)
CODE <- beta.fit %>%
filter(CODE == "RW", SPP %in% c("RS", "WS"))
CODE <- beta.fit %>%
filter(CODE == "BN", SPP %in% c("BS", "NS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
alpha.tukey <- HSD.test(alpha.aov, "SPP", group = TRUE)
beta.tukey <- HSD.test(beta.aov, "SPP", group = TRUE)
alpha.tukey
beta.tukey
summary(beta.aov)
summary(alpha.aov)
summary(beta.aov)
CODE <- beta.fit %>%
filter(CODE == "BR", SPP %in% c("BS", "RS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
CODE <- beta.fit %>%
filter(CODE == "BW", SPP %in% c("BS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
CODE <- beta.fit %>%
filter(CODE == "NR", SPP %in% c("NS", "RS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
CODE <- beta.fit %>%
filter(CODE == "NW", SPP %in% c("NS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
CODE <- beta.fit %>%
filter(CODE == "RW", SPP %in% c("RS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
library(multcomp)
beta.fit$SPP <- as.factor(beta.fit$SPP)
beta.fit$CODE <- as.factor(beta.fit$CODE)
amod <- lm(alpha ~ SPP + CODE, data = beta.fit)
bmod <- lm(beta ~ SPP + CODE, data = beta.fit)
summary(amod)
CODE <- beta.fit %>%
filter(CODE == "RW", SPP %in% c("RS", "WS"))
alpha.aov <- aov(alpha ~ SPP, data = CODE)
beta.aov <- aov(beta ~ SPP, data = CODE)
summary(alpha.aov)
summary(beta.aov)
#-------------------------------------------------------------------------------
# Volume predictions for all treatments
#-------------------------------------------------------------------------------
plot.summary <- spruce %>%
mutate(
ba = DBH.23^2 * 0.005454,
ef = 10,
c.area = (MCW/2)^2*pi,
ht.m = ht.fit/3.28,
dbh.cm = DBH.23*2.54)%>%
group_by(BLOCK, PLOT, CODE) %>%
summarize(
bapa = sum(ba * ef),
tpa = sum(ef),
qmd = qmd(bapa, tpa),
rd = relative.density.index(bapa, qmd),
volume.ha = sum(new.vol.m3*ef*2.47, na.rm = TRUE),
CCF = (sum(c.area*ef, na.rm = TRUE)/43560)*100,
LAI = mean(LAI, na.rm = TRUE))
head(plot.summary)
bl.t <- plot.summary%>%
left_join(.,site)%>%
mutate(baph = bapa/4.356,
tph = tpa*2.47)
head(bl.t)
bl.t <- bl.t %>%
filter(CODE != "C")
names(bl.t)
require(leaps)
modz <- regsubsets(volume.ha~BS_Suitability+WS_Suitability+RS_Suitability+
tri+tpi+roughness+SWI+LAI+
slope+aspect+flowdir+RAD+Winds10+SWI+tmean+ppt+
WD2000+SWC2+Winds10+Winds50+MeanWD+nit+ex.k+dep+ph,
data=bl.t)
summary(modz)
library(MASS)
b <- boxcox(lm(volume.ha ~ 1,data=bl.t))
# Exact lambda
lambda <- b$x[which.max(b$y)]
lambda
plot(density((bl.t$volume.ha)))
plot(density(sqrt(bl.t$volume.ha)))
plot(density(log(bl.t$volume.ha)))
bl.t$sq.vol <- sqrt(bl.t$volume.ha)
modz <- regsubsets(sq.vol~bapa+tpa+qmd+rd+CCF+LAI+BS_Suitability+WS_Suitability+RS_Suitability+
tri+tpi+roughness+SWI+
slope+aspect+flowdir+RAD+Winds10+SWI+tmean+ppt+
WD2000+SWC2+Winds10+Winds50+MeanWD+nit+ex.k+dep+ph,
data=bl.t)
summary(modz)
modz2 <- regsubsets(sq.vol~CCF+LAI+BS_Suitability+WS_Suitability+RS_Suitability+
tri+tpi+roughness+SWI+
slope+aspect+flowdir+RAD+Winds10+SWI+tmean+ppt+
WD2000+SWC2+Winds10+Winds50+MeanWD+nit+ex.k+dep+ph,
data=bl.t)
summary(modz2)
full.m1 <- lm(sq.vol~rd+CODE*aspect, data=bl.t) #LAI was significant prior to additional of structural and density attributes
summary(full.m1)
performance(full.m1)
require(car)
vif(full.m1)
AIC(full.m1)
full.mm <- lme(sq.vol~rd+CODE*aspect,data=bl.t,
random=~1|BLOCK,
na.action="na.omit")
AIC(full.mm,full.m1)
#fit
bl.t$new.fit.vol <- predict(full.m1, bl.t)
bl.t$new.fit.vol <- bl.t$new.fit.vol^2  #back transform sqrt(vol) and predict on dataset
view(bl.t)
library(multcomp)
vol.glht <- glht(full.m1, linfct = mcp(CODE = "Tukey"))
summary(vol.glht, p.adjust.method = "bonferroni")
cld(vol.glht, level = 0.05, decreasing = TRUE)
# volume is transformed (sqrt)
library(ggplot2)
library(ggeffects)
mydf2 <- ggpredict(full.m1,terms=c("rd","CODE","aspect"))
library(ggplot2)
ggplot(mydf2,aes(x=x,y=predicted,colour=group))+
geom_line(aes(linetype=group,color=group),size=1)+
#labs(x="Tree height (m)",y="Probabilty of sinuosity (%)")+
#ylim(0,55)+
#xlim(4,6)+
facet_wrap(~facet)+
theme_bw(18)
#back transform volume
mydf2 <- ggpredict(full.m1, terms = c("rd", "CODE", "aspect"))
# Back-transform from square root
mydf2$predicted <- mydf2$predicted^2
mydf2$conf.low <- mydf2$conf.low^2
mydf2$conf.high <- mydf2$conf.high^2
ggplot(mydf2, aes(x = x, y = predicted, colour = group)) +
geom_line(aes(linetype = group, color = group), size = 1) +
facet_wrap(~facet) +
ggtitle(expression(paste("Aspect (", degree, ")"))) +
labs(
x = "Relative Density (%)",
y = expression(paste("Volume (", m^3, " ", ha^-1, ")")),
colour = "Treatment",
linetype = "Treatment"
) +
theme_bw(18) +
theme(
plot.title = element_text(hjust = 0.5)  # centers the title
)
ggplot(mydf2, aes(x = x, y = predicted, colour = group)) +
geom_line(aes(linetype = group, color = group), size = 1) +
facet_wrap(~facet) +
ggtitle(expression(paste("Aspect (", degree, ")"))) +
labs(
x = "Relative Density (%)",
y = expression(paste("Volume (", m^3, " ", ha^-1, ")")),
colour = "Treatment",
linetype = "Treatment"
) +
coord_cartesian(ylim = c(0, 215)) +
theme_bw(18) +
theme(
plot.title = element_text(hjust = 0.5)  # centers the title
)
spruce$deductclass <- 5*as.integer((spruce$T_DEDUCT+(5/2))/5)
hist(spruce$deductclass)
hist(spruce$deductclass,
xlab = "Deduction (%)",
ylab = "Number of Trees",
main = "Distribution of Deduction Classes")
hist(spruce$deductclass,
xlab = "Deduction (%)",
ylab = "Number of Trees")
hist(spruce$deductclass,
xlab = "Deduction (%)",
ylab = "Number of Trees")
hist(spruce$deductclass,
xlab = "Deduction (%)",
ylab = "Number of Trees",
main = "Distribution of Deduction Classes")
